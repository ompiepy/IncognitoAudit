'use strict';

var path = require('path');
var testcontainers = require('testcontainers');
var midnightJsNetworkId = require('@midnight-ntwrk/midnight-js-network-id');
var node_zlib = require('node:zlib');
var fs = require('fs');
var fs$1 = require('node:fs');
var ledger = require('@midnight-ntwrk/ledger');
var midnightJsTypes = require('@midnight-ntwrk/midnight-js-types');
var zswap = require('@midnight-ntwrk/zswap');
var walletSdkHd = require('@midnight-ntwrk/wallet-sdk-hd');
var Rx = require('rxjs');
var axios = require('axios');
var promises = require('node:fs/promises');
var path$1 = require('node:path');
var pinoPretty = require('pino-pretty');
var pino = require('pino');
var wallet = require('@midnight-ntwrk/wallet');
var midnightJsLevelPrivateStateProvider = require('@midnight-ntwrk/midnight-js-level-private-state-provider');
var midnightJsIndexerPublicDataProvider = require('@midnight-ntwrk/midnight-js-indexer-public-data-provider');
var midnightJsNodeZkConfigProvider = require('@midnight-ntwrk/midnight-js-node-zk-config-provider');
var midnightJsHttpClientProofProvider = require('@midnight-ntwrk/midnight-js-http-client-proof-provider');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var Rx__namespace = /*#__PURE__*/_interopNamespaceDefault(Rx);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path$1);

const currentWorkingDir = path.resolve(`${process.cwd()}`);
const defaultContainersConfiguration = {
    proofServer: {
        path: currentWorkingDir,
        fileName: 'proof-server.yml',
        container: {
            name: 'proof-server',
            port: 6300,
            waitStrategy: testcontainers.Wait.forLogMessage('Actix runtime found; starting in Actix runtime')
        }
    },
    standalone: {
        path: currentWorkingDir,
        fileName: 'compose.yml',
        container: {
            proofServer: {
                name: 'proof-server',
                port: 6300,
                waitStrategy: testcontainers.Wait.forLogMessage('Actix runtime found; starting in Actix runtime')
            },
            node: {
                name: 'node',
                port: 9944,
                waitStrategy: testcontainers.Wait.forListeningPorts()
            },
            indexer: {
                name: 'indexer',
                port: 8088,
                waitStrategy: testcontainers.Wait.forListeningPorts()
            }
        }
    },
    log: {
        fileName: `tests_${new Date().toISOString().replace(/:/g, '_')}.log`,
        path: path.resolve(currentWorkingDir, 'logs', 'tests'),
        level: 'info'
    }
};
const latestContainersConfiguration = {
    ...defaultContainersConfiguration,
    standalone: {
        ...defaultContainersConfiguration.standalone,
        fileName: 'compose-latest.yml'
    },
    proofServer: {
        ...defaultContainersConfiguration.proofServer,
        fileName: 'proof-server-latest.yml'
    }
};
let containersConfiguration = defaultContainersConfiguration;
const getContainersConfiguration = () => {
    return containersConfiguration;
};
const setContainersConfiguration = (containersConfig) => {
    containersConfiguration = containersConfig;
};

/**
 * Abstract base class for test environments.
 * Provides common functionality for managing test wallets and environments.
 */
class TestEnvironment {
    /** Logger instance for recording operations */
    logger;
    /** Unique identifier for this test environment instance */
    uid;
    /**
     * Creates a new TestEnvironment instance.
     * @param {Logger} logger - Logger instance for recording operations
     */
    constructor(logger) {
        this.logger = logger;
        this.uid = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
    }
    /**
     * Starts a single wallet instance.
     * @returns {Promise<MidnightWalletProvider>} A promise that resolves to the started wallet
     * @throws {Error} If no wallet could be started
     */
    getMidnightWalletProvider = async () => {
        const [walletProvider] = await this.startMidnightWalletProviders();
        if (!walletProvider) {
            throw Error('Undefined walletProvider found, but expected to have one');
        }
        return walletProvider;
    };
}

/**
 * A proof server container that is started and stopped dynamically by the test
 * suite on random port.
 * @implements {ProofServerContainer}
 */
class DynamicProofServerContainer {
    /** The Docker Compose environment running the container */
    dockerEnv;
    /** Unique identifier for the container instance */
    uid;
    /** Configuration for the proof server container */
    config;
    /**
     * Creates a new DynamicProofServerContainer instance.
     * @param {StartedDockerComposeEnvironment} dockerEnv - The started Docker Compose environment
     * @param {string} uid - Unique identifier for the container
     * @private
     */
    constructor(dockerEnv, uid) {
        this.dockerEnv = dockerEnv;
        this.uid = uid;
        this.config = getContainersConfiguration().proofServer;
    }
    /**
     * Starts a new proof server container.
     * @param {Logger} logger - Logger instance for recording operations
     * @param {string} [maybeUID] - Optional unique identifier for the container
     * @param {string} [maybeNetworkId] - Optional network ID for the container
     * @returns {Promise<DynamicProofServerContainer>} A promise that resolves to the new container instance
     * @static
     */
    static async start(logger, maybeUID, maybeNetworkId) {
        const config = getContainersConfiguration().proofServer;
        const uid = maybeUID ?? Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
        const networkId = maybeNetworkId ?? midnightJsNetworkId.NetworkId[midnightJsNetworkId.getNetworkId()].toLowerCase();
        logger.info(`Starting proof server: path='${config.path}', file=${config.fileName}, networkId=${networkId}, uid=${uid}`);
        const dockerEnv = await new testcontainers.DockerComposeEnvironment(config.path, config.fileName)
            .withWaitStrategy(`${config.container.name}_${uid}`, config.container.waitStrategy)
            .withEnvironment({
            TESTCONTAINERS_UID: uid,
            NETWORK_ID: networkId
        })
            .up();
        return new DynamicProofServerContainer(dockerEnv, uid);
    }
    /**
     * Stops the proof server container.
     * @returns {Promise<void>} A promise that resolves when the container is stopped
     */
    async stop() {
        await this.dockerEnv.stop();
    }
    /**
     * Gets the mapped port number for the container.
     * @returns {number} The mapped port number
     */
    getMappedPort() {
        return this.dockerEnv
            .getContainer(`${this.config.container.name}_${this.uid}`)
            .getMappedPort(this.config.container.port);
    }
    /**
     * Gets the URL where the proof server can be accessed.
     * @returns {string} The URL of the proof server
     */
    getUrl() {
        return `http://localhost:${this.getMappedPort()}`;
    }
}
/**
 * A proof server that is currently running on a specific port.
 * Used for connecting to an existing proof server instance.
 * @implements {ProofServerContainer}
 */
class StaticProofServerContainer {
    /** The port number where the proof server is running */
    port;
    /**
     * Creates a new StaticProofServerContainer instance.
     * @param {number} port - The port number where the proof server is running (default: 6300)
     */
    constructor(port = 6300) {
        this.port = port;
    }
    /**
     * Gets the URL where the proof server can be accessed.
     * @returns {string} The URL of the proof server
     */
    getUrl() {
        return `http://localhost:${this.port}`;
    }
    /**
     * No-op stop method since this represents an external proof server.
     * @returns {Promise<void>} A resolved promise
     */
    // eslint-disable-next-line class-methods-use-this
    stop() {
        return Promise.resolve(undefined);
    }
}

/**
 * A class for compressing and decompressing files using gzip.
 */
class GzipFile {
    /** The path to the input file */
    inputFile;
    /** The path to the output file */
    outputFile;
    /**
     * Creates a new GzipFile instance.
     * @param inputFile - The path to the input file to compress/decompress
     * @param outputFile - The path where the compressed file will be saved
     */
    constructor(inputFile, outputFile) {
        this.inputFile = inputFile;
        this.outputFile = outputFile;
    }
    /**
     * Compresses the input file using gzip compression.
     * @returns A promise that resolves when compression is complete
     * @throws If there is an error during compression
     */
    compress = () => {
        const gzip = node_zlib.createGzip();
        const source = fs.createReadStream(this.inputFile);
        const destination = fs.createWriteStream(this.outputFile);
        return new Promise((resolve, reject) => {
            source
                .pipe(gzip)
                .pipe(destination)
                .on('finish', () => {
                resolve();
            })
                .on('error', (err) => {
                reject(err);
            });
        });
    };
    /**
     * Decompresses the input gzip file and returns its contents as a string.
     * @returns A promise that resolves with the decompressed file contents as a string
     * @throws If there is an error during decompression
     */
    decompress = () => {
        const gunzip = node_zlib.createGunzip();
        const source = fs.createReadStream(this.inputFile);
        return new Promise((resolve, reject) => {
            let data = '';
            source
                .pipe(gunzip)
                .on('data', (chunk) => {
                data += chunk.toString();
            })
                .on('end', () => {
                resolve(data);
            })
                .on('error', (err) => {
                reject(err);
            });
        });
    };
}

const getEnvVarEnvironment = () => {
    if (process.env.MN_TEST_ENVIRONMENT === undefined ||
        process.env.MN_TEST_ENVIRONMENT === 'undefined') {
        return 'undeployed';
    }
    return process.env.MN_TEST_ENVIRONMENT;
};
const getEnvVarNetworkId = () => {
    return process.env.MN_TEST_NETWORK_ID;
};
const getEnvVarWalletSeeds = () => {
    const envSeeds = process.env.MN_TEST_WALLET_SEED || process.env.TEST_WALLET_SEED;
    return envSeeds ? envSeeds.split(',') : undefined;
};
const MN_TEST_INDEXER = process.env.MN_TEST_INDEXER;
const MN_TEST_INDEXER_WS = process.env.MN_TEST_INDEXER_WS;
const MN_TEST_NODE = process.env.MN_TEST_NODE;
const MN_TEST_FAUCET = process.env.MN_TEST_FAUCET;

/** Default directory path for storing wallet state files */
const DEFAULT_WALLET_STATE_DIRECTORY = `./.states`;
/**
 * Generates a filename for the wallet state file based on environment and optional seed
 * @returns {string} Generated filename for the wallet state
 * @param seed
 */
const getWalletStateFilename = (seed) => {
    if (seed === undefined) {
        return `wallet.${getEnvVarEnvironment()}.state.gz`;
    }
    return `wallet.${getEnvVarEnvironment()}.${seed}.state.gz`;
};
/**
 * Provider class for saving and loading wallet state to/from compressed files
 */
class WalletSaveStateProvider {
    /** Logger instance for recording operations */
    logger;
    /** Absolute path to the directory containing wallet state files */
    directoryPath;
    /** Full path including filename for the wallet state file */
    filePath;
    /**
     * Creates a new WalletSaveStateProvider instance
     * @param {Logger} logger - Logger instance for recording operations
     * @param seed
     * @param {string} [directoryPath=DEFAULT_WALLET_STATE_DIRECTORY] - Directory path for wallet state files
     * @param {string} [filename] - Filename for the wallet state file
     */
    constructor(logger, seed, directoryPath = DEFAULT_WALLET_STATE_DIRECTORY, filename = getWalletStateFilename(seed)) {
        this.logger = logger;
        if (!directoryPath.startsWith('/')) {
            this.directoryPath = `${process.cwd()}/${directoryPath}`;
        }
        else {
            this.directoryPath = directoryPath;
        }
        this.filePath = `${this.directoryPath}/${filename}`;
    }
    /**
     * Saves the wallet state to a compressed file
     * @param {Wallet} wallet - The wallet instance to save state from
     * @returns {Promise<void>} A promise that resolves when the save is complete
     */
    async save(wallet) {
        this.logger.info(`Saving state in ${this.filePath}`);
        try {
            fs$1.mkdirSync(this.directoryPath, { recursive: true });
            const serializedState = await wallet.serializeState();
            try {
                const tempFile = `${this.filePath.replaceAll('.gz', '')}`;
                fs$1.writeFileSync(tempFile, serializedState);
                this.logger.info(`File '${tempFile}' written successfully.`);
                await new GzipFile(tempFile, `${this.filePath.replaceAll('.gz', '')}.gz`).compress();
                fs$1.rmSync(tempFile);
                this.logger.info(`File '${this.filePath}' written successfully.`);
            }
            catch (err) {
                this.logger.error(`Error writing file '${this.filePath}': ${err instanceof Error ? err.message : String(err)}`);
            }
        }
        catch (e) {
            this.logger.warn(e instanceof Error ? e.message : String(e));
        }
    }
    /**
     * Loads and decompresses the wallet state from a file
     * @returns {Promise<string>} A promise that resolves with the decompressed wallet state as a string
     * @throws {Error} If there is an error reading or decompressing the file
     */
    async load() {
        this.logger.info(`Loading state from ${this.filePath}`);
        try {
            return await new GzipFile(this.filePath, `${this.filePath.replaceAll('.gz', '')}.gz`).decompress();
        }
        catch (error) {
            this.logger.error(error instanceof Error ? error.message : String(error));
            throw error;
        }
    }
}

const { level } = getContainersConfiguration().log;
function createLogger(fileName, dir = getContainersConfiguration().log.path) {
    let logPath = path__namespace.resolve(fileName);
    if (!fileName.includes('/')) {
        logPath = path__namespace.resolve(dir, fileName);
    }
    const prettyStream = pinoPretty({
        colorize: true,
        sync: true
    });
    const prettyFileStream = pinoPretty({
        mkdir: true,
        colorize: false,
        sync: true,
        append: true,
        destination: logPath
    });
    return pino({
        level,
        depthLimit: 20
    }, pino.multistream([
        { stream: prettyStream, level },
        { stream: prettyFileStream, level }
    ]));
}
function createDefaultTestLogger() {
    return createLogger(getContainersConfiguration().log.fileName, getContainersConfiguration().log.path);
}
const logger = createDefaultTestLogger();

const MINUTE = 60_000;
/**
 * Creates a Promise that resolves after a specified delay.
 * @param ms The delay duration in milliseconds.
 * @returns A Promise that resolves after the specified delay.
 * @example
 * // Wait for 1 second
 * await delay(1000);
 */
const delay = (ms) => {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
};
/**
 * Deletes a directory and its contents recursively.
 * @param {string} dirPath - The path to the directory to delete
 * @returns {Promise<void>} A promise that resolves when the directory is deleted
 * @private
 */
const deleteDirectory = async (dirPath) => {
    try {
        const resolvedPath = path.resolve(dirPath);
        await promises.rm(resolvedPath, { recursive: true, force: true });
        logger.info(`Directory ${resolvedPath} deleted successfully.`);
    }
    catch (error) {
        if (error instanceof Error) {
            logger.error(`Error deleting directory: ${error.message}`);
        }
        else {
            logger.error('Unknown error occurred');
        }
    }
};
const extractHostnameAndPort = (url) => {
    const { hostname, port } = new URL(url);
    if (port !== '') {
        return `${hostname}:${port}`;
    }
    return hostname;
};

/**
 * Client for interacting with the Midnight faucet service.
 * Provides functionality to request test tokens for wallet addresses.
 */
class FaucetClient {
    faucetUrl;
    logger;
    /**
     * Creates a new FaucetClient instance.
     * @param {string} faucetUrl - The URL of the faucet service endpoint
     * @param {Logger} logger - Logger instance for recording operations
     */
    constructor(faucetUrl, logger) {
        this.faucetUrl = faucetUrl;
        this.logger = logger;
    }
    /**
     * Checks the health status of the faucet service.
     * Makes a GET request to the health endpoint of the faucet service.
     * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails
     */
    async health() {
        const url = `https://${extractHostnameAndPort(this.faucetUrl)}/api/health`;
        return axios
            .get(url, { timeout: 1000 })
            .then((r) => {
            this.logger.info(`Connected to faucet ${url}: ${JSON.stringify(r.data)}`);
            return r;
        })
            .catch((error) => {
            this.logger.warn(`Failed to connect to faucet service at '${url}'`, error);
        });
    }
    /**
     * Requests test tokens from the faucet for a specified wallet address.
     * Makes a POST request to the faucet service with the wallet address.
     * @param {string} walletAddress - The address to receive the test tokens
     * @returns {Promise<void>} A promise that resolves when the request is complete
     * @throws Will log but not throw if the request fails
     */
    async requestTokens(walletAddress) {
        this.logger.info(`Requesting tokens from '${this.faucetUrl}' for address: '${walletAddress}'`);
        try {
            const response = await axios.post(this.faucetUrl, {
                address: walletAddress,
                captchaToken: 'XXXX.DUMMY.TOKEN.XXXX'
            }, {
                headers: {
                    'Content-Type': 'application/json',
                    'x-turnstile-token': process.env.TURNSTILE_HEADER ?? ''
                }
            });
            this.logger.info(`Faucet response: ${response.statusText}`);
        }
        catch (error) {
            this.logger.error('Error requesting tokens:', error);
        }
    }
}

/**
 * Client for interacting with a Midnight node's JSON-RPC API
 */
class NodeClient {
    nodeURL;
    logger;
    /**
     * Creates a new NodeClient instance
     * @param {string} nodeURL - URL of the Midnight node
     * @param {Logger} logger - Logger instance for recording operations
     */
    constructor(nodeURL, logger) {
        this.nodeURL = nodeURL;
        this.logger = logger;
    }
    /**
     * Checks the health status of the node.
     * Makes a GET request to the health endpoint of the node.
     * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
     */
    async health() {
        const url = `https://${extractHostnameAndPort(this.nodeURL)}/health`;
        return axios
            .get(url, { timeout: 1000 })
            .then((r) => {
            this.logger.info(`Connected to node ${url}: ${JSON.stringify(r.data)}`);
            return r;
        })
            .catch((error) => {
            this.logger.warn(`Failed to connect to node at '${url}'`, error);
        });
    }
    /**
     * Validates response format and throws if unexpected
     * @param {AxiosResponse} response - Response from node API
     * @throws {Error} If response format is unexpected
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static throwOnUnexpected(response) {
        if (typeof response.data !== 'object' ||
            !response.data.result ||
            typeof response.data.result !== 'string') {
            throw new Error(`Unexpected response format: ${JSON.stringify(response.data)}`);
        }
    }
    /**
     * Makes a JSON-RPC request to the node
     * @param {string} method - RPC method name
     * @param {any[]} params - RPC method parameters
     * @returns {Promise<string>} Response result as string
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async jsonRPC(method, params) {
        const response = await axios.post(this.nodeURL, {
            id: 1,
            jsonrpc: '2.0',
            method,
            params
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        });
        this.logger.info(`Node response: ${response.statusText}`);
        NodeClient.throwOnUnexpected(response);
        return response.data.result;
    }
    /**
     * Fetches the state of a contract
     * @param {ContractAddress} contractAddress - Address of the contract
     * @returns {Promise<ContractState | null>} Contract state or null if not found
     */
    async contractState(contractAddress) {
        this.logger.info(`Fetching contract state for address '${contractAddress}'`);
        const result = await this.jsonRPC('midnight_contractState', [
            `${midnightJsNetworkId.networkIdToHex(midnightJsNetworkId.getNetworkId())}${contractAddress}`
        ]);
        return result === ''
            ? null
            : ledger.ContractState.deserialize(Buffer.from(result, 'hex'), midnightJsNetworkId.getLedgerNetworkId());
    }
    /**
     * Fetches the ledger state at a given block
     * @param {BlockHash} blockHash - Hash of the block
     * @returns {Promise<LedgerState>} Ledger state
     */
    async ledgerState(blockHash) {
        const blob = await this.ledgerStateBlob(blockHash);
        return ledger.LedgerState.deserialize(blob, midnightJsNetworkId.getLedgerNetworkId());
    }
    /**
     * Fetches the raw ledger state blob at a given block
     * @param {BlockHash} blockHash - Hash of the block
     * @returns {Promise<Uint8Array>} Raw ledger state data
     * @throws {Error} If no ledger state is found
     */
    async ledgerStateBlob(blockHash) {
        this.logger.info(`Fetching ledger state at block hash '${blockHash}'`);
        const result = await this.jsonRPC('midnight_getLedgerState', []);
        if (result === '') {
            throw new Error(`No ledger state found at block hash '${blockHash}'`);
        }
        return Buffer.from(result.slice(4), 'hex');
    }
    /**
     * Fetches the ledger version at a given block
     * @param {BlockHash} blockHash - Hash of the block
     * @returns {Promise<string>} Ledger version
     * @throws {Error} If no ledger version is found
     */
    async ledgerVersion(blockHash) {
        this.logger.info(`Fetching ledger version at block hash '${blockHash}'`);
        const result = await this.jsonRPC('midnight_ledgerVersion', []);
        if (result === '') {
            throw new Error(`No ledger version found at block hash '${blockHash}'`);
        }
        return result;
    }
}

class ProofServerClient {
    proofServer;
    logger;
    /**
     * Creates an instance of ProofServerClient.
     * @param {string} proofServer - The URL of the proof server service.
     * @param {Logger} logger - The logger instance for logging information.
     */
    constructor(proofServer, logger) {
        this.proofServer = proofServer;
        this.logger = logger;
    }
    /**
     * Checks the health status of the indexer service.
     * Makes a GET request to the status endpoint of the indexer service.
     * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
     */
    async health() {
        const url = `http://${extractHostnameAndPort(this.proofServer)}/health`;
        return axios
            .get(url, { timeout: 1000 })
            .then((r) => {
            this.logger.info(`Connected to proof server ${url}: ${JSON.stringify(r.data)}`);
            return r;
        })
            .catch((error) => {
            this.logger.warn(`Failed to connect to proof server at '${url}'`, error);
        });
    }
    /**
     * Proves a transaction by sending a POST request to the proof server.
     * @param data serialized transaction data
     * @param config Axios request configuration
     */
    async proveTx(data, config = {
        timeout: 3 * 60_000
    }) {
        const url = `http://${extractHostnameAndPort(this.proofServer)}/prove-tx`;
        return axios
            .post(url, data, config)
            .then((r) => {
            this.logger.info(`Received data from proof server ${url}`);
            return r;
        })
            .catch((error) => {
            this.logger.error(`Error in proof server at '${url}' ${error.toString()}`);
        });
    }
}

class IndexerClient {
    indexerUrl;
    logger;
    /**
     * Creates an instance of IndexerClient.
     * @param {string} indexerUrl - The URL of the indexer service.
     * @param {Logger} logger - The logger instance for logging information.
     */
    constructor(indexerUrl, logger) {
        this.indexerUrl = indexerUrl;
        this.logger = logger;
    }
    /**
     * Checks the health status of the indexer service.
     * Makes a GET request to the status endpoint of the indexer service.
     * @returns {Promise<AxiosResponse | void>} A promise that resolves to the response of the health check or logs an error if the request fails.
     */
    async health() {
        const url = `https://${extractHostnameAndPort(this.indexerUrl)}/ready`;
        return axios
            .get(url, { timeout: 1000 })
            .then((r) => {
            this.logger.info(`Connected to indexer ${url}: ${JSON.stringify(r.data)}`);
            return r;
        })
            .catch((error) => {
            this.logger.warn(`Failed to connect to indexer at '${url}'`, error);
        });
    }
}

/**
 * Gets the initial state of a wallet.
 * @param {MidnightWallet} wallet - The wallet to get the state from
 * @returns {Promise<WalletState>} The initial wallet state
 */
const getInitialState = async (wallet) => {
    logger.info('Getting initial state of wallet...');
    return Rx__namespace.firstValueFrom(wallet.state());
};
const logState = (state) => {
    if (state.syncProgress?.synced) {
        return 'Wallet is fully synced';
    }
    const indexerLag = state.syncProgress?.lag?.sourceGap.toString() ?? 'unknown';
    const walletLag = state.syncProgress?.lag?.applyGap.toString() ?? 'unknown';
    return `Wallet lag: ${walletLag}, Indexer lag: ${indexerLag}`;
};
/**
 * Waits for the wallet to fully synchronize with the network.
 * @param {Wallet} wallet - The wallet to wait for
 * @param {number} [throttleTime=5000] - Throttle time in milliseconds
 * @returns {Promise<WalletState>} The synchronized wallet state
 */
const waitForFullSync = (wallet, throttleTime = 3_000) => {
    logger.info('Waiting for full sync...');
    return Rx__namespace.firstValueFrom(wallet.state().pipe(Rx__namespace.throttleTime(throttleTime), Rx__namespace.tap((state) => {
        const txs = state.transactionHistory.length;
        logger.info(`${logState(state)}, transactions=${txs}`);
    }), Rx__namespace.filter((state) => {
        return state.syncProgress !== undefined && !state.syncProgress.synced;
    })));
};
/**
 * Waits for the wallet's sync progress to be defined.
 * @param {Wallet} wallet - The wallet to wait for
 * @param {number} [throttleTime=5000] - Throttle time in milliseconds
 * @returns {Promise<WalletState>} The wallet state with defined sync progress
 */
const waitForSyncProgressDefined = async (wallet, throttleTime = 3_000) => {
    logger.info('Waiting for sync progress to be defined...');
    return Rx__namespace.firstValueFrom(wallet.state().pipe(Rx__namespace.timeout(30_000), Rx__namespace.throttleTime(throttleTime), Rx__namespace.tap((state) => logger.info(logState(state))), Rx__namespace.filter((state) => {
        return state.syncProgress !== undefined;
    })));
};
/**
 * Synchronizes the wallet with the network and waits for a non-zero balance.
 * @param {Wallet} wallet - The wallet to synchronize
 * @param {number} [throttleTime=3000] - Throttle time in milliseconds
 * @returns {Promise<bigint>} A promise that resolves to the wallet balance when sync is close enough and balance is non-zero
 */
const syncWallet = (wallet, throttleTime = 3_000) => {
    logger.info('Syncing wallet...');
    return Rx__namespace.firstValueFrom(wallet.state().pipe(Rx__namespace.throttleTime(throttleTime), Rx__namespace.tap((state) => logger.info(logState(state))), Rx__namespace.filter((state) => state.syncProgress !== undefined && state.syncProgress.lag.applyGap < 100n), Rx__namespace.map((s) => s.balances[ledger.nativeToken()] ?? 0n), Rx__namespace.filter((balance) => balance > 0n)));
};
/**
 * Waits for funds to be available in the wallet.
 * If a faucet is configured, requests tokens from it.
 * @param {Wallet} wallet - The wallet to check for funds
 * @param {EnvironmentConfiguration} env - Environment configuration containing faucet details
 * @param {boolean} [fundFromFaucet=false] - Whether to request tokens from the faucet
 * @returns {Promise<bigint>} A promise that resolves to the wallet balance
 */
const waitForFunds = async (wallet, env, fundFromFaucet = false) => {
    const initialState = await getInitialState(wallet);
    logger.info(`Your wallet address is: ${initialState.address}, waiting for funds...`);
    if (fundFromFaucet && env.faucet) {
        logger.info('Requesting tokens from faucet...');
        await new FaucetClient(env.faucet, logger).requestTokens(initialState.address);
    }
    const initialBalance = initialState.balances[ledger.nativeToken()];
    if (initialBalance === undefined || initialBalance === 0n) {
        logger.info(`Your wallet balance is: 0`);
        logger.info(`Waiting to receive tokens...`);
        return syncWallet(wallet);
    }
    return initialBalance;
};
/**
 * Waits for the wallet to have pending coins.
 * @param {Wallet} wallet - The wallet to check for pending coins
 * @param {number} [throttleTime=1000] - Throttle time in milliseconds
 * @returns {Promise<WalletState>} The wallet state with pending coins
 */
const waitForPending = (wallet, throttleTime = 1_000) => {
    logger.info('Waiting for pending coins...');
    return Rx__namespace.firstValueFrom(wallet.state().pipe(Rx__namespace.throttleTime(throttleTime), Rx__namespace.tap((state) => {
        const pending = state.pendingCoins.length;
        logger.info(`Wallet pending coins: ${pending}, waiting for pending coins...`);
    }), Rx__namespace.filter((state) => state.pendingCoins.length > 0)));
};
/**
 * Waits for all pending coins to be finalized.
 * @param {Wallet} wallet - The wallet to check for finalized balance
 * @param {number} [throttleTime=5000] - Throttle time in milliseconds
 * @returns {Promise<WalletState>} The wallet state with no pending coins
 */
const waitForFinalizedBalance = (wallet, throttleTime = 5_000) => {
    logger.info('Waiting for pending coins to be finalized...');
    return Rx__namespace.firstValueFrom(wallet.state().pipe(Rx__namespace.throttleTime(throttleTime), Rx__namespace.tap((state) => {
        const pending = state.pendingCoins.length;
        logger.info(`Wallet pending coins: ${pending}, waiting for pending coins cleared...`);
    }), Rx__namespace.filter((state) => {
        const pending = state.pendingCoins.length;
        return pending === 0;
    })));
};
/**
 * Waits for a specific transaction ID to appear in the wallet's transaction history.
 * @param {string} txId - The transaction ID to wait for
 * @param {Wallet} wallet - The wallet to check
 * @param {number} [delayTime=1000] - Delay time in milliseconds
 * @returns {Promise<void>} Resolves when the transaction is found in history
 */
const waitForTxInHistory = async (txId, wallet, delayTime = 1_000) => {
    logger.info(`Waiting for txId ${txId} in history...`);
    const checkTxId = async () => {
        const state = await waitForFullSync(wallet);
        return state.transactionHistory.flatMap((tx) => tx.identifiers).includes(txId);
    };
    const pollTxId = async () => {
        logger.info('Waiting for a txId...');
        const foundTxId = await checkTxId();
        if (foundTxId) {
            logger.info(`TxId ${txId} found`);
        }
        else {
            await delay(delayTime);
            await pollTxId();
        }
    };
    await pollTxId();
};
/**
 * Returns a wallet state object without transaction history and coin data.
 * @param {WalletState} state - The wallet state to filter
 * @returns {Partial<WalletState>} Filtered wallet state
 */
const walletStateWithoutHistoryAndCoins = (state) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { transactionHistory, coins, availableCoins, ...rest } = state;
    return rest;
};
/**
 * Normalizes a wallet state by removing transaction details and sync progress.
 * @param {WalletState} state - The wallet state to normalize
 * @returns {object} Normalized wallet state
 */
const normalizeWalletState = (state) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const normalized = state.transactionHistory.map((txHistoryEntry) => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { transaction, ...otherProps } = txHistoryEntry;
        return otherProps;
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { transactionHistory, syncProgress, ...otherProps } = state;
    return { ...otherProps, normalized };
};
/**
 * Compares two wallet states for equality after normalization.
 * @param {WalletState} state1 - First wallet state to compare
 * @param {WalletState} state2 - Second wallet state to compare
 */
const expectStatesEqual = (state1, state2) => {
    expect(normalizeWalletState(state2)).toStrictEqual(normalizeWalletState(state1));
};
/**
 * Logs wallet state information.
 * @param {string} stateName - Name/identifier for the state being logged
 * @param {WalletState} state - The wallet state to log
 * @param {bigint} [balance] - Optional balance to log
 * @private
 */
const logWalletState = (stateName, state, balance) => {
    if (balance) {
        logger.info(`Wallet ${stateName}: ${balance}`);
    }
    logger.info(`Wallet ${stateName} available coins: ${state.availableCoins.length}`);
};
/**
 * Creates transaction outputs for a given address and amount.
 * @param {string} address - The receiver's address
 * @param {bigint} amount - The amount to send
 * @returns {TxOutput[]} Array of transaction outputs
 */
const createOutputs = (address, amount) => {
    return [
        {
            type: ledger.nativeToken(),
            amount,
            receiverAddress: address
        }
    ];
};
/**
 * Processes a transaction by proving and submitting it.
 * @param {MidnightWallet} wallet - The wallet to process the transaction with
 * @param {TxOutput[]} outputsToCreate - The outputs to create in the transaction
 * @returns {Promise<string>} The transaction ID
 * @private
 */
const processTransaction = async (wallet, outputsToCreate) => {
    const txToProve = await wallet.transferTransaction(outputsToCreate);
    logger.info('Proving tx...');
    const provenTx = await wallet.proveTransaction(txToProve);
    logger.info('Submitting tx...');
    return wallet.submitTransaction(provenTx);
};
/**
 * Validates the final state of a transaction.
 * @param {WalletState} finalState - The final wallet state
 * @param {WalletState} initialState - The initial wallet state
 * @param {bigint} initialBalance - The initial balance
 * @param {bigint} outputValue - The transaction output value
 * @private
 */
const validateFinalState = (finalState, initialState, initialBalance, outputValue) => {
    expect(finalState.balances[ledger.nativeToken()] ?? 0n).toBeLessThan(initialBalance - outputValue);
    expect(finalState.pendingCoins.length).toBe(0);
    expect(finalState.transactionHistory.length).toBeGreaterThanOrEqual(initialState.transactionHistory.length + 1);
    logger.info(`Wallet balance: ${finalState.balances[ledger.nativeToken()]}`);
};
/**
 * Sends a transaction to a specific address.
 * @param {MidnightWallet} walletWithFunds - The wallet to send funds from
 * @param {string} address - The recipient's address
 * @param {bigint} [outputValue=100_000_000n] - The amount to send
 * @returns {Promise<void>}
 */
const sendTransactionToAddress = async (walletWithFunds, address, outputValue = 100000000n) => {
    logger.info(`Sending ${outputValue} to address: ${address}`);
    const initialState = await getInitialState(walletWithFunds);
    const initialBalance = initialState.balances[ledger.nativeToken()] ?? 0n;
    logWalletState('Initial', initialState, initialBalance);
    const outputsToCreate = createOutputs(address, outputValue);
    const id = await processTransaction(walletWithFunds, outputsToCreate);
    logger.info(`Transaction id: ${id}`);
    const pendingState = await waitForPending(walletWithFunds);
    logWalletState('Pending', pendingState);
    const finalState = await waitForFinalizedBalance(walletWithFunds);
    logWalletState('Final', finalState);
    validateFinalState(finalState, initialState, initialBalance, outputValue);
};
/**
 * Sends a transaction from one wallet to another.
 * @param {MidnightWallet} walletWithFunds - The wallet to send funds from
 * @param {MidnightWallet} destination - The destination wallet
 * @returns {Promise<void>}
 */
const sendTransactionToWallet = async (walletWithFunds, destination) => {
    const state = await getInitialState(destination);
    logger.info(`Sending funds to address ${state.address}`);
    return sendTransactionToAddress(walletWithFunds, state.address);
};

const DEFAULT_WALLET_LOG_LEVEL = 'info';
class WalletFactory {
    /**
     * Builds a wallet instance based on the provided environment configuration and optional seed.
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {string} [seed] - Optional seed for wallet generation. If not provided, a new random wallet will be created
     * @param {LogLevel} [walletLogLevel] - Optional log level for wallet operations
     * @returns {Promise<Wallet>} A promise that resolves to the new wallet instance
     */
    static buildFromEnvContext = async (env, seed, walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) => {
        logger.info('Building wallet based on environment context');
        return seed
            ? WalletFactory.buildFromSeedAndTryToRestoreState(env, seed, DEFAULT_WALLET_STATE_DIRECTORY, getWalletStateFilename(seed), walletLogLevel)
            : WalletFactory.build(env, walletLogLevel);
    };
    /**
     * Builds a wallet instance based on the provided environment configuration.
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {LogLevel} [walletLogLevel=DEFAULT_WALLET_LOG_LEVEL] - Optional log level for wallet operations
     * @returns {Promise<MidnightWallet>} A promise that resolves to the new wallet instance
     */
    static build = async (env, walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) => {
        logger.info('Building wallet from scratch');
        const { indexer, indexerWS, node, proofServer } = env;
        return wallet.WalletBuilder.build(indexer, indexerWS, proofServer, node, Buffer.from(walletSdkHd.generateRandomSeed()).toString('hex'), midnightJsNetworkId.getZswapNetworkId(), walletLogLevel);
    };
    /**
     * Builds a wallet instance from a seed based on the provided environment configuration.
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {string} seed - Seed for wallet generation
     * @param {LogLevel} [walletLogLevel=DEFAULT_WALLET_LOG_LEVEL] - Optional log level for wallet operations
     * @returns {Promise<MidnightWallet>} A promise that resolves to the new wallet instance
     */
    static buildFromSeed = async (env, seed, walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) => {
        logger.info(`Building wallet from seed: ${seed}`);
        const { indexer, indexerWS, node, proofServer } = env;
        return wallet.WalletBuilder.buildFromSeed(indexer, indexerWS, proofServer, node, seed, midnightJsNetworkId.getZswapNetworkId(), walletLogLevel);
    };
    /**
     * Restores a wallet instance from a serialized state based on the provided environment configuration.
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {string} serialized - Serialized wallet state
     * @param {boolean} [trimTxHistory=true] - Optional flag to trim the transaction history during restoration
     * @param {LogLevel} [walletLogLevel=DEFAULT_WALLET_LOG_LEVEL] - Optional log level for wallet operations
     * @returns {Promise<MidnightWallet>} A promise that resolves to the restored wallet instance
     */
    static restore = async (env, serialized, seed, trimTxHistory = true, walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) => {
        logger.info('Restoring wallet from state');
        const { indexer, indexerWS, node, proofServer } = env;
        return wallet.WalletBuilder.restore(indexer, indexerWS, proofServer, node, seed, serialized, walletLogLevel, trimTxHistory);
    };
    /**
     * Builds a wallet from a seed and attempts to restore its state from a saved file if available.
     * @param {EnvironmentConfiguration} env - Configuration containing indexer, node, and proof server details
     * @param {string} seed - The seed to build the wallet from
     * @param {string} [directoryPath=DEFAULT_WALLET_STATE_DIRECTORY] - Directory path for wallet state file
     * @param {string} [filename=getWalletStateFilename()] - Filename for wallet state file
     * @param {LogLevel} [walletLogLevel='info'] - Log level for wallet operations
     * @returns {Promise<MidnightWallet>} The built and initialized wallet
     */
    static buildFromSeedAndTryToRestoreState = async (env, seed, directoryPath = DEFAULT_WALLET_STATE_DIRECTORY, filename = getWalletStateFilename(seed), walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) => {
        let wallet;
        const isAnotherChain = async (newWallet, offset) => {
            const state = await waitForSyncProgressDefined(newWallet);
            // allow for situations when there's no new index in the network between runs
            if (state.syncProgress !== undefined) {
                return state.syncProgress.lag.applyGap < offset - 1;
            }
            return false;
        };
        const handleWalletRestoration = async (serialized) => {
            wallet = await WalletFactory.restore(env, serialized, seed, true, walletLogLevel);
            const stateObjectFromFile = JSON.parse(serialized);
            if ((await isAnotherChain(wallet, stateObjectFromFile.offset)) ?? false) {
                logger.warn('The chain was reset, building wallet from scratch');
                wallet = await WalletFactory.build(env, walletLogLevel);
            }
            else {
                const newState = await waitForFullSync(wallet);
                if ((newState.syncProgress?.lag?.applyGap ?? 0n) < stateObjectFromFile.offset - 1) {
                    logger.warn('Wallet was not able to sync from restored state after sync');
                    wallet = await WalletFactory.build(env, walletLogLevel);
                }
                else {
                    logger.info('Wallet was able to sync from restored state');
                }
            }
            return wallet;
        };
        const restoreWalletFromFile = async () => {
            logger.info(`Attempting to restore state from ${directoryPath}/${filename}`);
            try {
                const serialized = await new WalletSaveStateProvider(logger, seed, directoryPath, `${filename}`).load();
                if (serialized !== undefined) {
                    wallet = await handleWalletRestoration(serialized);
                }
            }
            catch (error) {
                logger.error(error instanceof Error ? error.message : String(error));
                logger.warn('Wallet was not able to restore using the stored state, building wallet from scratch');
            }
        };
        logger.info(`Building wallet from seed ${seed} and trying to restore state`);
        logger.info(`Checking for wallet state file in ${directoryPath}/${filename}`);
        if (directoryPath != null && fs$1.existsSync(`${directoryPath}/${filename}`)) {
            await restoreWalletFromFile();
        }
        else {
            logger.info(directoryPath != null ? 'Wallet save file not found' : 'File path for save file not found');
        }
        if (wallet === undefined) {
            wallet = await WalletFactory.buildFromSeed(env, seed, walletLogLevel);
        }
        return wallet;
    };
}

/**
 * Provider class that implements wallet functionality for the Midnight network.
 * Handles transaction balancing, submission, and wallet state management.
 * @implements {MidnightProvider}
 * @implements {WalletProvider}
 * @implements {Resource}
 */
class MidnightWalletProvider {
    logger;
    env;
    wallet;
    coinPublicKey;
    encryptionPublicKey;
    /**
     * Creates a new MidnightWalletProvider instance.
     * @param {Logger} logger - Logger instance for recording operations
     * @param {EnvironmentConfiguration} environmentConfiguration - Configuration for the wallet environment
     * @param {MidnightWallet} wallet - Wallet instance
     * @param {CoinPublicKey} coinPublicKey - Public key for the wallet's coins
     * @private
     */
    constructor(logger, environmentConfiguration, wallet, coinPublicKey, encryptionPublicKey) {
        this.logger = logger;
        this.env = environmentConfiguration;
        this.wallet = wallet;
        this.coinPublicKey = coinPublicKey;
        this.encryptionPublicKey = encryptionPublicKey;
    }
    /**
     * Balances an unbalanced transaction by adding necessary inputs and change outputs.
     * @param {UnbalancedTransaction} tx - The unbalanced transaction to balance
     * @param {CoinInfo[]} newCoins - Array of new coins to include in the transaction
     * @returns {Promise<BalancedTransaction>} A promise that resolves to the balanced transaction
     */
    balanceTx(tx, newCoins) {
        return this.wallet
            .balanceTransaction(zswap.Transaction.deserialize(tx.serialize(midnightJsNetworkId.getLedgerNetworkId()), midnightJsNetworkId.getZswapNetworkId()), newCoins)
            .then((utx) => this.wallet.proveTransaction(utx))
            .then((zswapTx) => ledger.Transaction.deserialize(zswapTx.serialize(midnightJsNetworkId.getZswapNetworkId()), midnightJsNetworkId.getLedgerNetworkId()))
            .then(midnightJsTypes.createBalancedTx);
    }
    /**
     * Submits a balanced transaction to the network.
     * @param {BalancedTransaction} tx - The balanced transaction to submit
     * @returns {Promise<string>} A promise that resolves to the transaction hash
     */
    submitTx(tx) {
        return this.wallet.submitTransaction(zswap.Transaction.deserialize(tx.serialize(midnightJsNetworkId.getLedgerNetworkId()), midnightJsNetworkId.getZswapNetworkId()));
    }
    /**
     * Starts the wallet and optionally waits for funds to be available.
     * @param {boolean} waitForFundsInWallet - Whether to wait for funds to be available (default: true)
     * @returns {Promise<void>} A promise that resolves when the wallet is started and funds are available if requested
     */
    async start(waitForFundsInWallet = true) {
        this.logger.info('Starting wallet...');
        this.wallet.start();
        if (waitForFundsInWallet) {
            const balance = await waitForFunds(this.wallet, this.env, true);
            this.logger.info(`Your wallet balance is: ${balance}`);
        }
    }
    /**
     * Closes the wallet and releases resources.
     * @returns {Promise<void>} A promise that resolves when the wallet is closed
     */
    async close() {
        return this.wallet.close();
    }
    /**
     * Creates a new MidnightWalletProvider instance.
     * @param {Logger} logger - Logger instance for recording operations
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {string} [seed] - Optional seed for wallet generation. If not provided, a new random wallet will be created
     * @param {string} [walletLogLevel='info'] - Optional log level for wallet operations
     * @returns {Promise<MidnightWalletProvider>} A promise that resolves to the new wallet provider
     * @static
     */
    static async build(logger, env, seed, walletLogLevel = DEFAULT_WALLET_LOG_LEVEL) {
        const wallet = await WalletFactory.buildFromEnvContext(env, seed ?? Buffer.from(walletSdkHd.generateRandomSeed()).toString('hex'), walletLogLevel);
        const initialState = await getInitialState(wallet);
        logger.info(`Your wallet seed is: ${seed} and your address is: ${initialState.address}`);
        return new MidnightWalletProvider(logger, env, wallet, initialState.coinPublicKey, initialState.encryptionPublicKey);
    }
    /**
     * Creates a new MidnightWalletProvider instance using an existing wallet.
     * @param {Logger} logger - Logger instance for recording operations
     * @param {EnvironmentConfiguration} env - Configuration for the wallet environment
     * @param {MidnightWallet} wallet - Existing wallet instance to use
     * @returns {Promise<MidnightWalletProvider>} A promise that resolves to the new wallet provider using the existing wallet
     * @static
     */
    static async withWallet(logger, env, wallet) {
        const initialState = await getInitialState(wallet);
        return new MidnightWalletProvider(logger, env, wallet, initialState.coinPublicKey, initialState.encryptionPublicKey);
    }
}

/**
 * Base class for remote test environments that connect to external network services.
 * Provides functionality for managing walletProviders and a proof server container.
 */
class RemoteTestEnvironment extends TestEnvironment {
    proofServerContainer;
    environmentConfiguration;
    walletProviders = undefined;
    /**
     * Creates and starts the specified number of wallet providers.
     * @returns {Promise<MidnightWalletProvider[]>} Array of started wallet providers
     */
    startMidnightWalletProviders = async (amount = 1, seeds = getEnvVarWalletSeeds()) => {
        if (amount > 1 && seeds && seeds.length !== amount) {
            throw new Error(`Number of seeds provided (${seeds.length}) does not match the amount of wallets requested (${amount})`);
        }
        this.logger.info(`Getting ${amount} wallets...`);
        const buildWallet = (seed) => MidnightWalletProvider.build(this.logger, this.environmentConfiguration, seed);
        const seeds2 = seeds || Array(amount).fill(undefined);
        this.walletProviders = await Promise.all(seeds2.map(buildWallet));
        await Promise.all(this.walletProviders.map((wallet) => wallet.start()));
        return this.walletProviders;
    };
    /**
     * Shuts down the test environment by closing all walletProviders and stopping the proof server.
     */
    shutdown = async (saveWalletState) => {
        this.logger.info(`Shutting down test environment...`);
        if (this.walletProviders) {
            if (saveWalletState) {
                await Promise.all(this.walletProviders.map((midnightWallet) => new WalletSaveStateProvider(logger, midnightWallet.coinPublicKey).save(midnightWallet.wallet)));
            }
            await Promise.all(this.walletProviders.map((wallet) => wallet.close()));
        }
        if (this.proofServerContainer) {
            await this.proofServerContainer.stop();
        }
    };
    /**
     * Performs a health check for the environment.
     * Checks the health of the node, indexer, and optionally the faucet services.
     * @returns {Promise<void>} A promise that resolves when the health check is complete.
     */
    healthCheck = async () => {
        this.logger.info('Performing env health check');
        await new NodeClient(this.environmentConfiguration.node, this.logger).health();
        await new IndexerClient(this.environmentConfiguration.indexer, this.logger).health();
        await new ProofServerClient(this.environmentConfiguration.proofServer, this.logger).health();
        if (this.environmentConfiguration.faucet) {
            await new FaucetClient(this.environmentConfiguration.faucet, this.logger).health();
        }
    };
    /**
     * Starts the test environment by initializing the proof server and environment configuration.
     * @param {ProofServerContainer} maybeProofServerContainer Optional proof server container to use instead of creating a new one
     * @returns {Promise<EnvironmentConfiguration>} The environment configuration
     */
    start = async (maybeProofServerContainer) => {
        this.logger.info(`Starting test environment... `);
        this.proofServerContainer =
            maybeProofServerContainer ?? (await DynamicProofServerContainer.start(this.logger, this.uid));
        this.environmentConfiguration = this.getEnvironmentConfiguration();
        this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
        await this.healthCheck();
        return this.environmentConfiguration;
    };
}

/**
 * Configuration class for local test environment implementing EnvironmentConfiguration
 */
class LocalTestConfiguration {
    indexer;
    indexerWS;
    node;
    proofServer;
    faucet;
    /**
     * Creates a new LocalTestConfiguration instance
     * @param {ComponentPortsConfiguration} ports - Object containing port numbers for each component
     */
    constructor({ indexer, node, proofServer }) {
        this.indexer = `http://127.0.0.1:${indexer}/api/v1/graphql`;
        this.indexerWS = `ws://127.0.0.1:${indexer}/api/v1/graphql/ws`;
        this.node = `http://127.0.0.1:${node}`;
        this.proofServer = `http://127.0.0.1:${proofServer}`;
        this.faucet = undefined;
    }
}
/**
 * Test environment for local development using Docker containers
 * Manages containers for node, indexer and proof server components
 */
class LocalTestEnvironment extends TestEnvironment {
    static MAX_NUMBER_OF_WALLETS = 4;
    genesisMintWalletSeed = [
        '0000000000000000000000000000000000000000000000000000000000000001',
        '0000000000000000000000000000000000000000000000000000000000000002',
        '0000000000000000000000000000000000000000000000000000000000000003',
        '0000000000000000000000000000000000000000000000000000000000000004'
    ];
    config;
    environmentConfiguration;
    dockerEnv;
    walletProviders;
    /**
     * Creates a new LocalTestEnvironment instance
     * @param {Logger} logger - Logger instance for recording operations
     */
    constructor(logger) {
        super(logger);
        this.config = getContainersConfiguration().standalone;
    }
    /**
     * Gets the mapped ports for all containers in the environment
     * @returns {ComponentPortsConfiguration} Object containing mapped port numbers
     * @private
     */
    getMappedPorts = () => ({
        indexer: this.dockerEnv
            .getContainer(`${this.config.container.indexer.name}_${this.uid}`)
            .getMappedPort(this.config.container.indexer.port),
        node: this.dockerEnv
            .getContainer(`${this.config.container.node.name}_${this.uid}`)
            .getMappedPort(this.config.container.node.port),
        proofServer: this.dockerEnv
            .getContainer(`${this.config.container.proofServer.name}_${this.uid}`)
            .getMappedPort(this.config.container.proofServer.port)
    });
    /**
     * Instead of starting the test environment by building the docker containers
     * from the default configuration files in this package, start the test environment
     * by passing an existing {@link StartedDockerComposeEnvironment} along with the
     * ports for the containers in the environment.
     *
     * @param {StartedDockerComposeEnvironment} dockerEnv - A started docker compose environment
     * @param {ComponentPortsConfiguration} ports - The ports of the containers in the given environment
     * @returns {Promise<EnvironmentConfiguration>} The environment configuration
     */
    startWithInjectedEnvironment = async (dockerEnv, ports) => {
        this.logger.info(`Starting test environment...`);
        this.dockerEnv = dockerEnv;
        this.environmentConfiguration = new LocalTestConfiguration(ports);
        this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
        return this.environmentConfiguration;
    };
    /**
     * Starts the test environment by creating and configuring Docker containers
     * @param {ProofServerContainer} maybeProofServerContainer - Optional proof server container
     * @returns {Promise<EnvironmentConfiguration>} The environment configuration
     * @throws {Error} If trying to inject proof server container when starting new environment
     */
    start = async (maybeProofServerContainer) => {
        this.logger.info(`Starting test environment... path=${this.config.path}, file=${this.config.fileName}, uid=${this.uid}`);
        if (maybeProofServerContainer) {
            throw new Error('Invalid usage, trying to inject proof server container instance when starting new test environment with another proof server...');
        }
        this.dockerEnv = await new testcontainers.DockerComposeEnvironment(this.config.path, this.config.fileName)
            .withWaitStrategy(`${this.config.container.proofServer.name}_${this.uid}`, this.config.container.proofServer.waitStrategy)
            .withWaitStrategy(`${this.config.container.node.name}_${this.uid}`, this.config.container.node.waitStrategy)
            .withWaitStrategy(`${this.config.container.indexer.name}_${this.uid}`, this.config.container.indexer.waitStrategy)
            .withEnvironment({
            TESTCONTAINERS_UID: this.uid,
            NETWORK_ID: midnightJsNetworkId.NetworkId[midnightJsNetworkId.getNetworkId()].toLowerCase()
        })
            .up();
        this.environmentConfiguration = new LocalTestConfiguration(this.getMappedPorts());
        this.logger.info(`Test environment configuration: ${JSON.stringify(this.environmentConfiguration)}`);
        return this.environmentConfiguration;
    };
    /**
     * Shuts down the test environment, closing walletProviders and stopping containers
     * @returns {Promise<void>}
     */
    shutdown = async (saveWalletState) => {
        this.logger.info(`Shutting down test environment...`);
        if (this.walletProviders) {
            if (saveWalletState) {
                this.logger.warn('Skipping wallet save state as it is obsolete in this context...');
            }
            await Promise.all(this.walletProviders.map((wallet) => wallet.close()));
        }
        if (this.dockerEnv) {
            await this.dockerEnv.down({ timeout: 10000, removeVolumes: true });
        }
    };
    /**
     * Creates and starts the specified number of wallet providers
     * @throws {Error} If requested amount exceeds maximum supported walletProviders
     * @returns {Promise<MidnightWalletProvider[]>} A promise that resolves to an array of started wallets
     */
    startMidnightWalletProviders = async (amount = 1, seeds = getEnvVarWalletSeeds()) => {
        this.logger.info(`Getting ${amount} wallets...`);
        if (seeds) {
            this.logger.warn('Provided seeds will be ignored, using genesis mint wallet seeds');
        }
        if (amount > LocalTestEnvironment.MAX_NUMBER_OF_WALLETS) {
            throw new Error(`Maximum supported number of wallets for this environment reached: ${LocalTestEnvironment.MAX_NUMBER_OF_WALLETS}`);
        }
        this.walletProviders = await Promise.all(Array.from({ length: amount }).map((_elem, index) => MidnightWalletProvider.build(this.logger, this.environmentConfiguration, this.genesisMintWalletSeed[index])));
        await Promise.all(this.walletProviders.map((wallet) => wallet.start()));
        return this.walletProviders;
    };
}

/**
 * Test environment configuration for the Midnight QA network.
 * Provides URLs and endpoints for QA network services.
 */
class QanetTestEnvironment extends RemoteTestEnvironment {
    /**
     * Returns the configuration for the QA network environment services.
     * @returns {EnvironmentConfiguration} Object containing URLs for QA network services:
     * - indexer: GraphQL API endpoint for the indexer
     * - indexerWS: WebSocket endpoint for the indexer
     * - node: RPC endpoint for the blockchain node
     * - faucet: API endpoint for requesting test tokens
     * - proofServer: URL for the proof generation server
     */
    getEnvironmentConfiguration() {
        return {
            indexer: 'https://indexer.qanet.dev.midnight.network/api/v1/graphql',
            indexerWS: 'wss://indexer.qanet.dev.midnight.network/api/v1/graphql/ws',
            node: 'https://rpc.qanet.dev.midnight.network',
            faucet: 'https://faucet.qanet.dev.midnight.network/api/request-tokens',
            proofServer: this.proofServerContainer.getUrl()
        };
    }
}

/**
 * Test environment configuration for the Midnight devnet network.
 * Provides URLs and endpoints for devnet services.
 */
class DevnetTestEnvironment extends RemoteTestEnvironment {
    /**
     * Returns the configuration for the devnet environment services.
     * @returns {EnvironmentConfiguration} Object containing URLs for devnet services:
     * - indexer: GraphQL API endpoint for the indexer
     * - indexerWS: WebSocket endpoint for the indexer
     * - node: RPC endpoint for the blockchain node
     * - faucet: API endpoint for requesting test tokens
     * - proofServer: URL for the proof generation server
     */
    getEnvironmentConfiguration() {
        return {
            indexer: 'https://indexer.devnet.midnight.network/api/v1/graphql',
            indexerWS: 'wss://indexer.devnet.midnight.network/api/v1/graphql/ws',
            node: 'https://rpc.devnet.midnight.network',
            faucet: 'https://faucet.devnet.midnight.network/api/request-tokens',
            proofServer: this.proofServerContainer.getUrl()
        };
    }
}

/**
 * Test environment configuration for the Midnight testnet network.
 * Provides URLs and endpoints for testnet services.
 */
class TestnetTestEnvironment extends RemoteTestEnvironment {
    /**
     * Returns the configuration for the testnet environment services.
     * @returns {EnvironmentConfiguration} Object containing URLs for testnet services:
     * - indexer: GraphQL API endpoint for the indexer
     * - indexerWS: WebSocket endpoint for the indexer
     * - node: RPC endpoint for the blockchain node
     * - faucet: API endpoint for requesting test tokens
     * - proofServer: URL for the proof generation server
     */
    getEnvironmentConfiguration() {
        return {
            indexer: 'https://indexer.testnet.midnight.network/api/v1/graphql',
            indexerWS: 'wss://indexer.testnet.midnight.network/api/v1/graphql/ws',
            node: 'https://rpc.testnet.midnight.network',
            faucet: 'https://faucet.testnet.midnight.network/api/request-tokens',
            proofServer: this.proofServerContainer.getUrl()
        };
    }
}

/**
 * Test environment configuration for the Midnight testnet network.
 * Provides URLs and endpoints for testnet services.
 */
class Testnet2TestEnvironment extends RemoteTestEnvironment {
    /**
     * Returns the configuration for the testnet environment services.
     * @returns {EnvironmentConfiguration} Object containing URLs for testnet services:
     * - indexer: GraphQL API endpoint for the indexer
     * - indexerWS: WebSocket endpoint for the indexer
     * - node: RPC endpoint for the blockchain node
     * - faucet: API endpoint for requesting test tokens
     * - proofServer: URL for the proof generation server
     */
    getEnvironmentConfiguration() {
        return {
            indexer: 'https://indexer.testnet-02.midnight.network/api/v1/graphql',
            indexerWS: 'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws',
            node: 'https://rpc.testnet-02.midnight.network',
            faucet: 'https://faucet.testnet-02.midnight.network/api/request-tokens',
            proofServer: this.proofServerContainer.getUrl()
        };
    }
}

/**
 * An error representing a required, but missing, environment variable.
 */
class MissingEnvironmentVariable extends Error {
    environmentVariable;
    /**
     * @param environmentVariable The name of the missing environment variable.
     */
    constructor(environmentVariable) {
        super(`Environment variable '${environmentVariable}' is required`);
        this.environmentVariable = environmentVariable;
    }
}

/**
 * List of required environment variables that must be set for this test environment
 */
const MN_REQUIRED_ENVIRONMENT_VARIABLES = ['MN_TEST_INDEXER', 'MN_TEST_INDEXER_WS', 'MN_TEST_NODE'];
/**
 * Test environment that configures services using environment variables.
 * Allows specifying custom endpoints through environment variables.
 */
class EnvVarRemoteTestEnvironment extends RemoteTestEnvironment {
    /**
     * Returns the configuration for environment services based on environment variables.
     * Required environment variables:
     * - MN_TEST_INDEXER: GraphQL API endpoint for the indexer
     * - MN_TEST_INDEXER_WS: WebSocket endpoint for the indexer
     * - MN_TEST_NODE: RPC endpoint for the blockchain node
     * Optional environment variables:
     * - MN_TEST_FAUCET: API endpoint for requesting test tokens
     * @returns {EnvironmentConfiguration} Object containing service URLs from environment variables
     * @throws {MissingEnvironmentVariable} If any required environment variable is not set
     */
    getEnvironmentConfiguration() {
        // Throw is any of the required MN_* environment variables are missing.
        MN_REQUIRED_ENVIRONMENT_VARIABLES.forEach((envVar) => {
            if (!process.env[envVar]) {
                throw new MissingEnvironmentVariable(envVar);
            }
        });
        return {
            indexer: MN_TEST_INDEXER,
            indexerWS: MN_TEST_INDEXER_WS,
            node: MN_TEST_NODE,
            faucet: MN_TEST_FAUCET,
            proofServer: this.proofServerContainer.getUrl()
        };
    }
}

/**
 * Parses the network ID from the environment variable.
 * @throws {MissingEnvironmentVariable} If MN_TEST_NETWORK_ID is not set.
 * @throws {NetworkIdTypeError} If the network ID is invalid.
 * @returns {NetworkId} The parsed network ID.
 */
const parseNetworkIdEnvVar = () => {
    const networkIdEnv = getEnvVarNetworkId();
    if (!networkIdEnv) {
        throw new MissingEnvironmentVariable('MN_TEST_NETWORK_ID');
    }
    const networkId = midnightJsNetworkId.stringToNetworkId(networkIdEnv);
    if (!networkId) {
        throw new midnightJsNetworkId.NetworkIdTypeError(networkIdEnv);
    }
    return networkId;
};
/**
 * Returns the appropriate test environment based on the MN_TEST_ENVIRONMENT variable.
 * @param {Logger} logger - The logger instance to be used by the test environment.
 * @returns {TestnetTestEnvironment | DevnetTestEnvironment | QanetTestEnvironment | EnvVarRemoteTestEnvironment | LocalTestEnvironment} The selected test environment instance.
 */
const getTestEnvironment = (logger) => {
    const testEnv = getEnvVarEnvironment().toLowerCase();
    switch (testEnv) {
        case 'testnet':
            midnightJsNetworkId.setNetworkId(midnightJsNetworkId.NetworkId.TestNet);
            return new TestnetTestEnvironment(logger);
        case 'testnet-02':
            midnightJsNetworkId.setNetworkId(midnightJsNetworkId.NetworkId.TestNet);
            return new Testnet2TestEnvironment(logger);
        case 'devnet':
            midnightJsNetworkId.setNetworkId(midnightJsNetworkId.NetworkId.DevNet);
            return new DevnetTestEnvironment(logger);
        case 'qanet':
            midnightJsNetworkId.setNetworkId(midnightJsNetworkId.NetworkId.DevNet);
            return new QanetTestEnvironment(logger);
        case 'env-var-remote':
            midnightJsNetworkId.setNetworkId(parseNetworkIdEnvVar());
            return new EnvVarRemoteTestEnvironment(logger);
        default:
            midnightJsNetworkId.setNetworkId(midnightJsNetworkId.NetworkId.Undeployed);
            return new LocalTestEnvironment(logger);
    }
};

/**
 * Configures and returns the required providers for a Midnight contract.
 *
 * @template ICK - Type parameter for the input circuit key string
 * @template PS - Type parameter for the private state
 *
 * @param {MidnightWalletProvider} midnightWalletProvider - The midnightWalletProvider provider instance to use for transactions
 * @param {EnvironmentConfiguration} environmentConfiguration - Configuration for the environment including indexer and proof server details
 * @param {ContractConfiguration} contractConfiguration - Configuration specific to the contract including storage names and ZK config path
 *
 * @returns {MidnightProviders} An object containing all configured providers:
 *   - privateStateProvider: For managing private contract state
 *   - publicDataProvider: For accessing public blockchain data
 *   - zkConfigProvider: For zero-knowledge proof configurations
 *   - proofProvider: For generating and verifying proofs
 *   - walletProvider: For midnightWalletProvider operations
 *   - midnightProvider: For Midnight-specific operations
 */
const initializeMidnightProviders = (midnightWalletProvider, environmentConfiguration, contractConfiguration) => {
    return {
        privateStateProvider: midnightJsLevelPrivateStateProvider.levelPrivateStateProvider({
            privateStateStoreName: contractConfiguration.privateStateStoreName,
            signingKeyStoreName: `${contractConfiguration.privateStateStoreName}-signing-keys`
        }),
        publicDataProvider: midnightJsIndexerPublicDataProvider.indexerPublicDataProvider(environmentConfiguration.indexer, environmentConfiguration.indexerWS),
        zkConfigProvider: new midnightJsNodeZkConfigProvider.NodeZkConfigProvider(contractConfiguration.zkConfigPath),
        proofProvider: midnightJsHttpClientProofProvider.httpClientProofProvider(environmentConfiguration.proofServer),
        walletProvider: midnightWalletProvider,
        midnightProvider: midnightWalletProvider
    };
};

/**
 * A simple in-memory implementation of private state provider. Makes it easy to capture and rewrite private state from deploy.
 * @template PSI - Type of the private state identifier.
 * @template PS - Type of the private state.
 * @returns {PrivateStateProvider<PSI, PS>} An in-memory private state provider.
 */
const inMemoryPrivateStateProvider = () => {
    const record = new Map();
    const signingKeys = {};
    return {
        /**
         * Sets the private state for a given key.
         * @param {PSI} key - The key for the private state.
         * @param {PS} state - The private state to set.
         * @returns {Promise<void>} A promise that resolves when the state is set.
         */
        set(key, state) {
            record.set(key, state);
            return Promise.resolve();
        },
        /**
         * Gets the private state for a given key.
         * @param {PSI} key - The key for the private state.
         * @returns {Promise<PS | null>} A promise that resolves to the private state or null if not found.
         */
        get(key) {
            const value = record.get(key) ?? null;
            return Promise.resolve(value);
        },
        /**
         * Removes the private state for a given key.
         * @param {PSI} key - The key for the private state.
         * @returns {Promise<void>} A promise that resolves when the state is removed.
         */
        remove(key) {
            record.delete(key);
            return Promise.resolve();
        },
        /**
         * Clears all private states.
         * @returns {Promise<void>} A promise that resolves when all states are cleared.
         */
        clear() {
            record.clear();
            return Promise.resolve();
        },
        /**
         * Sets the signing key for a given contract address.
         * @param {ContractAddress} contractAddress - The contract address.
         * @param {SigningKey} signingKey - The signing key to set.
         * @returns {Promise<void>} A promise that resolves when the signing key is set.
         */
        setSigningKey(contractAddress, signingKey) {
            signingKeys[contractAddress] = signingKey;
            return Promise.resolve();
        },
        /**
         * Gets the signing key for a given contract address.
         * @param {ContractAddress} contractAddress - The contract address.
         * @returns {Promise<SigningKey | null>} A promise that resolves to the signing key or null if not found.
         */
        getSigningKey(contractAddress) {
            const value = signingKeys[contractAddress] ?? null;
            return Promise.resolve(value);
        },
        /**
         * Removes the signing key for a given contract address.
         * @param {ContractAddress} contractAddress - The contract address.
         * @returns {Promise<void>} A promise that resolves when the signing key is removed.
         */
        removeSigningKey(contractAddress) {
            delete signingKeys[contractAddress];
            return Promise.resolve();
        },
        /**
         * Clears all signing keys.
         * @returns {Promise<void>} A promise that resolves when all signing keys are cleared.
         */
        clearSigningKeys() {
            Object.keys(signingKeys).forEach((contractAddress) => {
                delete signingKeys[contractAddress];
            });
            return Promise.resolve();
        }
    };
};

const stateValueEqual = (a, b) => {
    return a.toString(false) === b.toString(false);
};
const txsEqual = (a, b) => {
    return a.toString(false) === b.toString(false);
};
const expectFoundAndDeployedTxPublicDataEqual = (deployTxData, foundDeployTxData) => {
    expect(stateValueEqual(deployTxData.public.initialContractState.data, foundDeployTxData.public.initialContractState.data)).toBeTruthy();
    expect(deployTxData.public.contractAddress).toEqual(foundDeployTxData.public.contractAddress);
    expect(deployTxData.public.blockHash).toEqual(foundDeployTxData.public.blockHash);
    expect(deployTxData.public.blockHeight).toEqual(foundDeployTxData.public.blockHeight);
    expect(deployTxData.public.txHash).toEqual(foundDeployTxData.public.txHash);
    expect(deployTxData.public.txId).toEqual(foundDeployTxData.public.txId);
    expect(deployTxData.public.status).toEqual(foundDeployTxData.public.status);
    expect(txsEqual(deployTxData.public.tx, foundDeployTxData.public.tx)).toBeTruthy();
};
const expectFoundAndDeployedTxPrivateDataEqual = (deployTxData, foundDeployTxData) => {
    // For our purposes, we always find with the same private state that the contract is deployed with
    // so this comparison is justified.
    expect(deployTxData.private.initialPrivateState).toEqual(foundDeployTxData.private.initialPrivateState);
};
const expectFoundAndDeployedTxDataEqual = (deployTxData, foundDeployTxData) => {
    expectFoundAndDeployedTxPublicDataEqual(deployTxData, foundDeployTxData);
    expectFoundAndDeployedTxPrivateDataEqual(deployTxData, foundDeployTxData);
};
const expectFoundAndDeployedStatesEqual = async (providers, deployTxData, foundDeployTxData, privateStateId, initialPrivateState) => {
    const deployedLedgerState = await providers.publicDataProvider.queryContractState(deployTxData.public.contractAddress);
    expect(deployedLedgerState).toBeDefined();
    expect(stateValueEqual(deployedLedgerState.data, foundDeployTxData.public.initialContractState.data)).toBeTruthy();
    if (privateStateId) {
        const privateState = await providers.privateStateProvider.get(privateStateId);
        expect(privateState).toEqual(foundDeployTxData.private.initialPrivateState);
        if (initialPrivateState !== undefined) {
            expect(privateState).toEqual(initialPrivateState);
        }
    }
};
const expectSuccessfulTxData = (finalizedTxData) => {
    expect(finalizedTxData.status).toEqual(midnightJsTypes.SucceedEntirely);
    expect(finalizedTxData.tx).toBeTruthy();
    expect(finalizedTxData.txId).toBeTruthy();
    expect(finalizedTxData.txHash).toBeTruthy();
    expect(finalizedTxData.blockHeight).toBeTruthy();
    expect(finalizedTxData.blockHash).toBeTruthy();
};
const expectSuccessfulDeployTx = async (providers, deployTxData, deployTxOptions) => {
    expectSuccessfulTxData(deployTxData.public);
    expect(deployTxData.public.contractAddress).toBeTruthy();
    const deployedLedgerState = await providers.publicDataProvider.queryContractState(deployTxData.public.contractAddress);
    expect(stateValueEqual(deployTxData.public.initialContractState.data, deployedLedgerState.data));
    expect(deployTxData.public.initialContractState).toBeTruthy();
    // Checks that the signing key and private state passed in the deploy configuration
    // were stored correctly.
    if (deployTxOptions) {
        if (deployTxOptions.signingKey) {
            expect(deployTxData.private.signingKey).toEqual(deployTxOptions.signingKey);
            const storedSigningKey = await providers.privateStateProvider.getSigningKey(deployTxData.public.contractAddress);
            expect(storedSigningKey).toBeDefined();
            expect(storedSigningKey).toEqual(deployTxOptions.signingKey);
        }
        // We only test contracts that pass 'initialPrivateState' through the contract constructor unchanged
        // so this equality comparison is justified.
        if ('privateStateId' in deployTxOptions && 'initialPrivateState' in deployTxOptions) {
            expect(deployTxData.private.initialPrivateState).toEqual(deployTxOptions.initialPrivateState);
            const storedPrivateState = await providers.privateStateProvider.get(deployTxOptions.privateStateId);
            expect(storedPrivateState).toBeDefined();
            expect(storedPrivateState).toEqual(deployTxOptions.initialPrivateState);
        }
    }
};
const expectSuccessfulCallTx = async (providers, callTxData, callTxOptions, nextPrivateState) => {
    expectSuccessfulTxData(callTxData.public);
    expect(callTxData.public.nextContractState).toBeTruthy();
    expect(callTxData.private.nextZswapLocalState);
    if (callTxOptions) {
        if ('privateStateId' in callTxOptions) {
            const storedPrivateState = await providers.privateStateProvider.get(callTxOptions.privateStateId);
            expect(storedPrivateState).toBeDefined();
            expect(storedPrivateState).toEqual(callTxData.private.nextPrivateState);
            if (nextPrivateState) {
                expect(nextPrivateState).toEqual(callTxData.private.nextPrivateState);
            }
        }
    }
};

exports.DEFAULT_WALLET_LOG_LEVEL = DEFAULT_WALLET_LOG_LEVEL;
exports.DEFAULT_WALLET_STATE_DIRECTORY = DEFAULT_WALLET_STATE_DIRECTORY;
exports.DevnetTestEnvironment = DevnetTestEnvironment;
exports.DynamicProofServerContainer = DynamicProofServerContainer;
exports.EnvVarRemoteTestEnvironment = EnvVarRemoteTestEnvironment;
exports.FaucetClient = FaucetClient;
exports.GzipFile = GzipFile;
exports.IndexerClient = IndexerClient;
exports.LocalTestConfiguration = LocalTestConfiguration;
exports.LocalTestEnvironment = LocalTestEnvironment;
exports.MINUTE = MINUTE;
exports.MidnightWalletProvider = MidnightWalletProvider;
exports.NodeClient = NodeClient;
exports.ProofServerClient = ProofServerClient;
exports.QanetTestEnvironment = QanetTestEnvironment;
exports.RemoteTestEnvironment = RemoteTestEnvironment;
exports.StaticProofServerContainer = StaticProofServerContainer;
exports.TestEnvironment = TestEnvironment;
exports.Testnet2TestEnvironment = Testnet2TestEnvironment;
exports.TestnetTestEnvironment = TestnetTestEnvironment;
exports.WalletFactory = WalletFactory;
exports.WalletSaveStateProvider = WalletSaveStateProvider;
exports.createDefaultTestLogger = createDefaultTestLogger;
exports.createLogger = createLogger;
exports.createOutputs = createOutputs;
exports.defaultContainersConfiguration = defaultContainersConfiguration;
exports.delay = delay;
exports.deleteDirectory = deleteDirectory;
exports.expectFoundAndDeployedStatesEqual = expectFoundAndDeployedStatesEqual;
exports.expectFoundAndDeployedTxDataEqual = expectFoundAndDeployedTxDataEqual;
exports.expectFoundAndDeployedTxPrivateDataEqual = expectFoundAndDeployedTxPrivateDataEqual;
exports.expectFoundAndDeployedTxPublicDataEqual = expectFoundAndDeployedTxPublicDataEqual;
exports.expectStatesEqual = expectStatesEqual;
exports.expectSuccessfulCallTx = expectSuccessfulCallTx;
exports.expectSuccessfulDeployTx = expectSuccessfulDeployTx;
exports.expectSuccessfulTxData = expectSuccessfulTxData;
exports.extractHostnameAndPort = extractHostnameAndPort;
exports.getContainersConfiguration = getContainersConfiguration;
exports.getInitialState = getInitialState;
exports.getTestEnvironment = getTestEnvironment;
exports.getWalletStateFilename = getWalletStateFilename;
exports.inMemoryPrivateStateProvider = inMemoryPrivateStateProvider;
exports.initializeMidnightProviders = initializeMidnightProviders;
exports.latestContainersConfiguration = latestContainersConfiguration;
exports.logger = logger;
exports.normalizeWalletState = normalizeWalletState;
exports.processTransaction = processTransaction;
exports.sendTransactionToAddress = sendTransactionToAddress;
exports.sendTransactionToWallet = sendTransactionToWallet;
exports.setContainersConfiguration = setContainersConfiguration;
exports.stateValueEqual = stateValueEqual;
exports.syncWallet = syncWallet;
exports.txsEqual = txsEqual;
exports.validateFinalState = validateFinalState;
exports.waitForFinalizedBalance = waitForFinalizedBalance;
exports.waitForFullSync = waitForFullSync;
exports.waitForFunds = waitForFunds;
exports.waitForPending = waitForPending;
exports.waitForSyncProgressDefined = waitForSyncProgressDefined;
exports.waitForTxInHistory = waitForTxInHistory;
exports.walletStateWithoutHistoryAndCoins = walletStateWithoutHistoryAndCoins;
//# sourceMappingURL=index.cjs.map
